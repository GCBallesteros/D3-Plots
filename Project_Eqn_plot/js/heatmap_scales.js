// Generated by CoffeeScript 1.8.0
(function() {
  var heatmap, pl1,
    __modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  heatmap = (function() {
    function heatmap() {}

    heatmap.prototype.width = 600;

    heatmap.prototype.height = 400;

    heatmap.prototype.margin = {
      top: 70,
      right: 70,
      bottom: 70,
      left: 70
    };

    heatmap.prototype.nx = 0;

    heatmap.prototype.ny = 0;

    heatmap.prototype.plot = function() {
      var color_brewer, data, extX, extY, h, height_tile, height_tile_px, maxZ, minZ, svg, w, width_tile, width_tile_px, xPoints, xScale, yPoints, yScale, zHeight, zScale;
      w = this.width - this.margin.left - this.margin.right;
      h = this.height - this.margin.top - this.margin.bottom;
      xScale = d3.scale.linear().range([0, w]);
      yScale = d3.scale.linear().range([h, 0]);
      xPoints = d3.range(0, 2 * Math.PI, 0.40);
      heatmap.prototype.nx = xPoints.length;
      yPoints = d3.range(0, 2 * Math.PI, 0.40);
      heatmap.prototype.ny = yPoints.length;
      data = heatmap.prototype.generate_data(xPoints, yPoints);
      minZ = data.min;
      maxZ = data.max;
      zHeight = data.z;
      extX = d3.extent(xPoints);
      extY = d3.extent(yPoints);
      width_tile = (extX[1] - extX[0]) / (this.nx - 1);
      height_tile = (extY[1] - extY[0]) / (this.ny - 1);
      xScale.domain([extX[0] - width_tile / 2, extX[1] + width_tile / 2]);
      yScale.domain([extY[0] - height_tile / 2, extY[1] + height_tile / 2]);
      color_brewer = [[33, 102, 172], [67, 147, 195], [146, 197, 222], [209, 229, 240], [247, 247, 247], [253, 219, 199], [244, 165, 130], [214, 96, 77], [178, 24, 43]];
      zScale = heatmap.prototype.colourScale([minZ, maxZ], color_brewer);
      width_tile_px = xScale(width_tile) - xScale(0);
      height_tile_px = yScale(0) - yScale(height_tile);
      svg = d3.select("body").append("svg").attr("width", w + this.margin.left + this.margin.right).attr("height", h + this.margin.top + this.margin.bottom).append("g").attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
      svg.append("g").attr("class", "tiling").selectAll(".tile").data(heatmap.prototype.flatten(zHeight)).enter().append("rect").attr("class", "tile").attr("x", function(d, i) {
        return xScale(xPoints[heatmap.prototype.idx2row(i)] - width_tile / 2);
      }).attr("y", function(d, i) {
        return yScale(yPoints[heatmap.prototype.idx2col(i)] + height_tile / 2);
      }).attr("width", width_tile_px).attr("height", height_tile_px).style("fill", function(d) {
        return zScale(d);
      }).style("stroke", function(d) {
        return zScale(d);
      }).style("stroke-width", "1px").on("mouseover", function(d, i) {
        var xPosition, yPosition;
        xPosition = parseFloat(d3.select(this).attr("x"));
        yPosition = parseFloat(d3.select(this).attr("y"));
        svg.append("text").attr("id", "tooltipX").attr("x", xPosition).attr("y", h + 12).attr("text-anchor", "middle").attr("font-family", "sans-serif").attr("font-size", "11px").attr("font-weight", "bold").attr("fill", "black").text(xPoints[heatmap.prototype.idx2row(i)]);
        svg.append("text").attr("id", "tooltipY").attr("x", -12).attr("y", yPosition).attr("text-anchor", "middle").attr("font-family", "sans-serif").attr("font-size", "11px").attr("font-weight", "bold").attr("fill", "black").text(yPoints[heatmap.prototype.idx2col(i)]);
        svg.append("line").attr("id", "xLine").attr("x1", xPosition + width_tile_px / 2).attr("y1", yPosition + height_tile_px / 2).attr("x2", 10).attr("y2", yPosition + height_tile_px / 2).style("stroke", "white").style("stroke-dasharray", "3, 3").style("stroke-width", "1px");
        return svg.append("line").attr("id", "yLine").attr("x1", xPosition + width_tile_px / 2).attr("y1", yPosition + height_tile_px / 2).attr("x2", xPosition + width_tile_px / 2).attr("y2", h + height_tile_px).style("stroke", "white").style("stroke-dasharray", "3, 3").style("stroke-width", "1px");
      }).on("mouseout", function() {
        d3.select("#xLine").remove();
        d3.select("#yLine").remove();
        d3.select("#tooltipX").remove();
        return d3.select("#tooltipY").remove();
      });
      return void 0;
    };

    heatmap.prototype.func = function(vx, vy) {
      return Math.cos(vx) * Math.cos(vy);
    };

    heatmap.prototype.idx2row = function(idx) {
      return __modulo(idx, this.nx);
    };

    heatmap.prototype.idx2col = function(idx) {
      return Math.floor(idx / this.nx);
    };

    heatmap.prototype.flatten = function(ar) {
      return [].concat.apply([], ar.valueOf());
    };

    heatmap.prototype.generate_data = function(x, y) {
      var i, j, maxZ, minZ, new_val, vx, vy, zHeight, _i, _j, _len, _len1;
      zHeight = math.zeros(this.ny, this.nx);
      minZ = this.func(x[0], y[0]);
      maxZ = this.func(x[0], y[0]);
      for (j = _i = 0, _len = y.length; _i < _len; j = ++_i) {
        vy = y[j];
        for (i = _j = 0, _len1 = x.length; _j < _len1; i = ++_j) {
          vx = x[i];
          new_val = Math.cos(vy) * Math.cos(vx);
          zHeight.valueOf()[j][i] = new_val;
          if (new_val > maxZ) {
            maxZ = new_val;
          }
          if (new_val < minZ) {
            minZ = new_val;
          }
        }
      }
      return {
        z: zHeight,
        min: minZ,
        max: maxZ
      };
    };

    heatmap.prototype.colourScale = function(domain, colors) {
      var cScale, deltaColor, extD, nColors;
      nColors = colors.length;
      deltaColor = 1 / (nColors - 1);
      extD = d3.extent(domain);
      cScale = function(d) {
        var c, color_end, color_start, cout, idx, r, _i;
        r = (extD[1] - d) / (extD[1] - extD[0]);
        idx = Math.floor(r * (nColors - 1));
        if (idx >= nColors - 1) {
          idx = nColors - 2;
        }
        r = (r - idx * deltaColor) * (nColors - 1);
        color_start = colors[idx];
        color_end = colors[idx + 1];
        cout = "rgb(";
        for (c = _i = 0; _i <= 2; c = ++_i) {
          cout = cout + Math.floor(color_start[c] + r * (color_end[c] - color_start[c])) + ",";
        }
        cout = cout.slice(0, cout.length - 1) + ")";
        return cout;
      };
      return cScale;
    };

    return heatmap;

  })();

  pl1 = new heatmap;

  pl1.plot();

}).call(this);
